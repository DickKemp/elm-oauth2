module OAuth.AuthorizationCode exposing
    ( Authorization, AuthorizationResult(..), AuthorizationSuccess, AuthorizationError, parseCode, makeAuthUrl
    , Authentication, Credentials, AuthenticationSuccess, AuthenticationError, RequestParts, makeTokenRequest, authenticationErrorDecoder
    )

{-| The authorization code grant type is used to obtain both access
tokens and refresh tokens and is optimized for confidential clients.
Since this is a redirection-based flow, the client must be capable of
interacting with the resource owner's user-agent (typically a web
browser) and capable of receiving incoming requests (via redirection)
from the authorization server.

This is a 3-step process:

  - The client asks for an authorization to the OAuth provider: the user is redirected.
  - The provider redirects the user back and the client parses the request query parameters from the url.
  - The client authenticate itself using the authorization code found in the previous step.

After those steps, the client owns an `access_token` that can be used to authorize any subsequent
request.


## Authorize

@docs Authorization, AuthorizationResult, AuthorizationSuccess, AuthorizationError, parseCode, makeAuthUrl


## Authenticate

@docs Authentication, Credentials, AuthenticationSuccess, AuthenticationError, RequestParts, makeTokenRequest, authenticationErrorDecoder

-}

import Internal as Internal exposing (..)
import Json.Decode as Json
import OAuth exposing (ErrorCode, Token, errorCodeFromString)
import Url exposing (Url)
import Url.Builder as Builder
import Url.Parser as Url exposing ((<?>))
import Url.Parser.Query as Query



--
-- Authorize
--


type alias Authorization =
    Internal.Authorization


type alias AuthorizationError =
    Internal.AuthorizationError ErrorCode


{-| The response obtained as a result of an authorization

  - code (_REQUIRED_):
    The authorization code generated by the authorization server. The authorization code MUST expire
    shortly after it is issued to mitigate the risk of leaks. A maximum authorization code lifetime of
    10 minutes is RECOMMENDED. The client MUST NOT use the authorization code more than once. If an
    authorization code is used more than once, the authorization server MUST deny the request and
    SHOULD revoke (when possible) all tokens previously issued based on that authorization code. The
    authorization code is bound to the client identifier and redirection URI.

  - state (_REQUIRED if `state` was present in the authorization request_):
    The exact value received from the client

-}
type alias AuthorizationSuccess =
    { code : String
    , state : Maybe String
    }


{-| Describes errors coming from attempting to parse a url after an OAuth redirection

  - Empty: means there were nothing (related to OAuth 2.0) to parse
  - Error: a successfully parsed OAuth 2.0 error
  - Success: a successfully parsed the response

-}
type AuthorizationResult
    = Empty
    | Error AuthorizationError
    | Success AuthorizationSuccess


{-| Redirects the resource owner (user) to the resource provider server using the specified
authorization flow.
-}
makeAuthUrl : Authorization -> Url
makeAuthUrl =
    Internal.makeAuthUrl Internal.Code


{-| Parse the location looking for a parameters set by the resource provider server after
redirecting the resource owner (user).

Fails with a `AuthorizationResult Empty` when there's nothing

-}
parseCode : Url -> AuthorizationResult
parseCode url_ =
    let
        url =
            { url_ | path = "/" }
    in
    case Url.parse (Url.top <?> Query.map2 Tuple.pair codeParser (errorParser errorCodeFromString)) url of
        Just ( Just code, _ ) ->
            parseUrlQuery url Empty (Query.map Success <| authorizationSuccessParser code)

        Just ( _, Just error ) ->
            parseUrlQuery url Empty (Query.map Error <| authorizationErrorParser error)

        _ ->
            Empty


authorizationSuccessParser : String -> Query.Parser AuthorizationSuccess
authorizationSuccessParser code =
    Query.map (AuthorizationSuccess code)
        stateParser


codeParser : Query.Parser (Maybe String)
codeParser =
    Query.string "code"



--
-- Authenticate
--


{-| Request configuration for an AuthorizationCode authentication

    let authentication =
          { credentials =
              -- Only the clientId is required. Specify a secret
              -- if a Basic OAuth is required by the resource
              -- provider
              { clientId = "<my-client-id>"
              , secret = Nothing
              }
          -- Authorization code from the authorization result
          , code = "<authorization-code>"
          -- Token endpoint of the resource provider
          , url = "<token-endpoint>"
          -- Redirect Uri to your webserver
          , redirectUri = "<my-web-server>"
          }

-}
type alias Authentication =
    { credentials : Credentials
    , code : String
    , redirectUri : Url
    , url : Url
    }


type alias AuthenticationSuccess =
    Internal.AuthenticationSuccess


type alias AuthenticationError =
    Internal.AuthenticationError ErrorCode


type alias RequestParts a =
    Internal.RequestParts a


{-| Describes at least a `clientId` and if define, a complete set of credentials with the `secret`
-}
type alias Credentials =
    { clientId : String
    , secret : Maybe String
    }


authenticationErrorDecoder : Json.Decoder AuthenticationError
authenticationErrorDecoder =
    Internal.authenticationErrorDecoder (errorDecoder errorCodeFromString)


{-| Builds a the request components required to get a token from an authorization code

    let req : Http.Request AuthenticationSuccess
        req = makeTokenRequest authentication |> Http.request

-}
makeTokenRequest : Authentication -> RequestParts AuthenticationSuccess
makeTokenRequest { credentials, code, url, redirectUri } =
    let
        body =
            [ Builder.string "grant_type" "authorization_code"
            , Builder.string "client_id" credentials.clientId
            , Builder.string "redirect_uri" (makeRedirectUri redirectUri)
            , Builder.string "code" code
            ]
                |> Builder.toQuery
                |> String.dropLeft 1

        headers =
            makeHeaders <|
                case credentials.secret of
                    Nothing ->
                        Nothing

                    Just secret ->
                        Just { clientId = credentials.clientId, secret = secret }
    in
    makeRequest url headers body
